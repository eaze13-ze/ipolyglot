diff --git a/node_modules/nel/lib/nel.js b/node_modules/nel/lib/nel.js
index f2391d6..05874d7 100755
--- a/node_modules/nel/lib/nel.js
+++ b/node_modules/nel/lib/nel.js
@@ -199,7 +199,9 @@ Session._command = paths.node;
  * @member {String[]}
  * @private
  */
-Session._args = ["--eval", server]; // --eval workaround
+// some useful flags for debugging, turn on if need be
+// Session._args = ["--polyglot", "--jvm", "--inspect", "--inspect.Suspend=false", "--experimental-options", "--inspect.Internal=true", "--eval", server]; // --eval workaround
+Session._args = ["--polyglot", "--jvm", "--eval", server]; // --eval workaround
 
 /**
  * Combination of a piece of code to be run within a session and all the
diff --git a/node_modules/nel/lib/server/main.js b/node_modules/nel/lib/server/main.js
index 6935d32..24b0fb1 100755
--- a/node_modules/nel/lib/server/main.js
+++ b/node_modules/nel/lib/server/main.js
@@ -44,6 +44,7 @@ var DEBUG = !!process.env.DEBUG;
 var log;
 var requester;
 var initialContext;
+var esprima = require('esprima');
 
 // Init IPC server
 init();
@@ -313,6 +314,168 @@ function inspect(object) {
     }
 }
 
-function run(code) {
+function __run(rawCode) {
+    const POLYGLOT_MAGIC_PATTERN = '%polyglot ';
+
+    if(rawCode.startsWith(POLYGLOT_MAGIC_PATTERN)) {
+        const rawCodeSplit = rawCode.split('\n');
+        const firstLine = rawCodeSplit.shift();
+
+        const firstLineSplit = firstLine.split(' ');
+        const languageFromMagic = firstLineSplit[1];
+
+        if(languageFromMagic === 'js' && !Polyglot.import('js_blacklist')) {
+            const blacklist = Polyglot.eval('js', 'Object.keys(global)');
+            Polyglot.export('js_blacklist', blacklist);
+        }
+        const blacklist = Polyglot.import('js_blacklist')
+
+        const code = rawCodeSplit.join('\n');
+        const evalResultToBeReturned = Polyglot.eval(languageFromMagic, code);
+        console.debug('evaluation of actual code succeeded');
+
+        let varsToBeExported = []
+        if(languageFromMagic === 'js') {
+            varsToBeExported = Polyglot.eval('js', 'Object.keys(global)');
+            varsToBeExported = varsToBeExported.filter(e => blacklist.indexOf(e) === -1)
+        } else {
+            varsToBeExported = firstLineSplit.slice(2);
+        }
+        varsToBeExported = Array.from(new Set(varsToBeExported));
+        console.log('these will be exported', varsToBeExported);
+
+        let varExportCodeStatements = varsToBeExported.reduce(
+            (code, varIdentifier) => {
+                let newExportLine = '';
+                if (languageFromMagic === 'js') {
+                    newExportLine = `Polyglot.export('${varIdentifier}', ${varIdentifier})`;
+                } else if (languageFromMagic === 'ruby') {
+                    // attempt to export the var prefixed with the global var identifier '$'
+                    // as a workaround for https://github.com/oracle/truffleruby/issues/1695
+                    newExportLine = `Polyglot.export('${varIdentifier}', $${varIdentifier})`;
+                } else if (languageFromMagic === 'python') {
+                    newExportLine = `import polyglot;polyglot.export_value(${varIdentifier}, '${varIdentifier}')`;
+                } else if (languageFromMagic === 'R') {
+                    newExportLine = `export('${varIdentifier}', ${varIdentifier})`;
+                }
+
+                code.push(newExportLine);
+                return code;
+            }, []
+        );
+
+        const separator = languageFromMagic === 'js' ? ';' : '';
+        const varExportCode = varExportCodeStatements.join(`${separator}\n`) + separator;
+        console.debug('varExportCode to be evaluated in the next step');
+        console.debug('--------------\n' + varExportCode + '\n--------------');
+        Polyglot.eval(languageFromMagic, varExportCode);
+        console.debug('evaluation of var export code succeeded');
+
+        let exportedVarsOld = Polyglot.import('__bindings')
+        if(!exportedVarsOld) {
+            exportedVarsOld = [];
+        }
+        const exportedVarsNew = Array.from(new Set(exportedVarsOld.concat(varsToBeExported)));
+        console.debug('new __bindings:', exportedVarsNew);
+        Polyglot.export('__bindings', exportedVarsNew);
+
+        return evalResultToBeReturned;
+    }
+
     return vm.runInThisContext(code);
 }
+
+
+function defaultLanguageStatements(variableName = '__i') {
+    // globalVariables: returning actual array raises error (see: https://github.com/graalvm/graaljs/issues/173)
+    return {
+        'python': {
+            'importVariable': `import polyglot; ${variableName} = polyglot.import_value("${variableName}")`,
+            'exportVariable': `import polyglot; polyglot.export_value(${variableName}, "${variableName}")`,
+            'globalVariables': `repr(list(globals().keys())).replace("'", '"')`,
+        },
+        'R': {
+            'importVariable': `${variableName} <- import("${variableName}")`,
+            'exportVariable': `export("${variableName}", ${variableName})`,
+            'globalVariables': `paste('["', paste(ls(all.names=TRUE), collapse='", "'), '"]', sep="")`,
+        },
+        'ruby': {
+            'importVariable': `${variableName} = Polyglot.import("${variableName}")`,
+            'exportVariable': `Polyglot.export("${variableName}", ${variableName})`,
+            'globalVariables': 'require "json"; local_variables.to_json',
+        },
+        'js': {
+            'importVariable': `${variableName} = Polyglot.import("${variableName}")`,
+            'exportVariable': `Polyglot.export("${variableName}", ${variableName})`,
+            'globalVariables': 'JSON.stringify(Object.keys(global))',
+        },
+    }
+}
+
+
+function loadGlobalVariables(language) {
+    // TODO: replace string repr with actual arrays (see: https://github.com/graalvm/graaljs/issues/173 and above)
+    return JSON.parse(Polyglot.eval(language, defaultLanguageStatements()[language]['globalVariables']));
+}
+
+
+function loadPolyglotBlacklist(language) {
+    let polyglotVariableBlacklist = Polyglot.import('__polyglotVariableBlacklist');
+    if (!polyglotVariableBlacklist) {
+        polyglotVariableBlacklist = {};
+    }
+
+    if (!polyglotVariableBlacklist[language]) {
+        let newPolyglotVariableBlacklist = loadGlobalVariables(language);
+        polyglotVariableBlacklist[language] = newPolyglotVariableBlacklist;
+        Polyglot.export('__polyglotVariableBlacklist', polyglotVariableBlacklist);
+    }
+
+    return polyglotVariableBlacklist[language];
+}
+
+
+function importPolyglotVariables(language) {
+    let variableList = Polyglot.import('__bindings');
+    if (!variableList) {
+        variableList = [];
+        Polyglot.export('__bindings', variableList)
+    }
+
+    for (let i of variableList) {
+        Polyglot.eval(language, defaultLanguageStatements(i)[language]['importVariable']);
+    }
+}
+
+
+function exportPolyglotVariables(language) {
+    let polyglotVariableBlacklist = loadPolyglotBlacklist(language);
+
+    let newPolyglotVariables = loadGlobalVariables(language);
+    let newPolyglotVariablesWoBlacklisted = newPolyglotVariables.filter(x => !polyglotVariableBlacklist.includes(x));
+    for (let i of newPolyglotVariablesWoBlacklisted) {
+        Polyglot.eval(language, defaultLanguageStatements(i)[language]['exportVariable']);
+    }
+
+    Polyglot.export('__bindings', newPolyglotVariablesWoBlacklisted);
+}
+
+
+function run(rawCode) {
+    const POLYGLOT_MAGIC_PATTERN = '%polyglot ';
+
+    if(rawCode.startsWith(POLYGLOT_MAGIC_PATTERN)) {
+        const rawCodeSplit = rawCode.split('\n');
+        const languageFromMagic = rawCodeSplit[0].replace(POLYGLOT_MAGIC_PATTERN, '');
+        const code = rawCodeSplit.slice(1).join('\n');
+
+        loadPolyglotBlacklist(languageFromMagic);
+        importPolyglotVariables(languageFromMagic);
+        const result = Polyglot.eval(languageFromMagic, code);
+        exportPolyglotVariables(languageFromMagic);
+
+        return result;
+    }
+
+    return vm.runInThisContext(rawCode);
+}
